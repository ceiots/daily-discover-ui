# Daily Discover - 前端主题设计系统架构与AI开发规范 v4.0

## 1. 核心原则与目标

本设计系统旨在构建一个**高性能、高可扩展、视觉高度一致**的前端UI体系。它不仅是组件库，更是指导AI进行高效、规范开发的核心规则集。

- **核心目标**：**效率提升与性能优化**。通过规范化、原子化的方式，最大化AI自主开发的范围，减少人工干预，实现快速迭代。
- **设计哲学**：**遵循原子设计（Atomic Design）**。将UI拆分为原子、分子、有机体、模板和页面五个层次，确保组件的独立性、复用性和可组合性。
- **性能第一**：所有组件和功能的设计都必须将性能作为首要考量，实施懒加载、代码分割、虚拟列表等策略，确保首屏加载时间<1.5s。
- **体验一致**：通过设计令牌（Design Tokens）和严格的开发规范，确保产品在所有场景下提供统一、可预测的用户体验。
- **可测试性**：每个组件必须具备良好的可测试性，支持单元测试和端到端测试，确保质量。
- **可扩展性**：采用插件化架构，支持功能的动态加载和卸载，为未来扩展做好准备。
- **逻辑与视图分离**：严格区分逻辑层(Hooks)和视图层(JSX)，提高代码可维护性和复用性。

## 2. 架构设计

### 2.1 原子设计（Atomic Design）分层

我们遵循原子设计思想，对`src/theme`目录进行逻辑分层：

- **Atoms (原子)**：构成UI的最基础元素，不可再分。
  - **职责**：只负责样式，不包含业务逻辑。
  - **特点**：高度可复用，几乎不包含状态，主要关注样式。
  - **示例**：`Text.js`、`Button.js`、`PageTitle.js`等基础样式元素。
- **Molecules (分子)**：由多个原子组合而成的简单UI组件。
  - **职责**：完成一个独立的、简单的功能。
  - **特点**：实现特定的UI功能，可包含简单交互。
  - **示例**：`InfoCard.js`、`Card.js`、`ShopInfo.js`、`ScrollableSection.js`。
- **Organisms (有机体)**：由多个分子或原子构成的复杂、独立的UI区域。
  - **职责**：代表产品中一个明确的功能区域。
  - **特点**：实现完整的业务功能，可能包含复杂状态。
  - **示例**：`NavBar.js`、`TopBar.js`、`Toast`组件等。
- **Templates (模板)**：定义页面的整体布局和骨架。
  - **职责**：关注页面结构，不关心具体内容，是可复用的页面框架。
  - **特点**：定义页面骨架，接收内容填充。
  - **示例**：`BasePage.js`。

### 2.2 目录结构（优化后）

```
daily-discover-ui/src/theme/
├── components/              # UI组件 (按原子设计分层)
│   ├── atoms/              # 原子级组件
│   │   ├── Button.js       # 基础按钮组件
│   │   ├── Text.js         # 文本组件
│   │   ├── PageTitle.js    # 页面标题组件
│   │   └── index.js        # 导出文件
│   ├── molecules/          # 分子级组件
│   │   ├── Card.js         # 卡片组件
│   │   ├── InfoCard.js     # 信息卡片组件
│   │   ├── ShopInfo.js     # 店铺信息组件
│   │   ├── ScrollableSection.js # 可滚动区域组件
│   │   └── index.js        # 导出文件
│   ├── organisms/          # 有机体级组件
│   │   ├── NavBar.js       # 导航栏组件
│   │   ├── TopBar.js       # 顶部栏组件
│   │   ├── Toast/          # 轻提示组件
│   │   └── index.js        # 导出文件
│   └── templates/          # 模板级组件
│       ├── BasePage.js     # 基础页面布局
│       └── index.js        # 导出文件
├── hooks/                   # 组件逻辑钩子
│   ├── useToast.js         # Toast钩子
│   └── index.js            # 导出文件
├── providers/               # 全局状态提供者
│   └── ToastProvider.js    # Toast上下文提供者
├── styles/                  # 样式工具
│   ├── uiConstants.js       # UI设计常量
│   ├── styleUtils.js        # 样式工具函数
│   └── commonStyles.js      # 通用样式
├── utils/                   # 工具函数
│   ├── performance.js       # 性能优化工具
│   ├── testing.js           # 测试辅助工具
│   └── analytics.js         # 分析与监控工具
├── tokens.js                # 设计令牌
├── GlobalStyles.js          # 全局样式
├── ThemeProvider.js         # 主题上下文
└── index.js                 # 主题系统统一导出
```

### 2.3 技术架构

- **核心技术栈**：React + styled-components + React Context
- **状态管理**：React Context + useReducer 模式，避免状态碎片化
- **样式方案**：styled-components 结合 Design Tokens，实现主题切换
- **组件加载**：React.lazy() + Suspense 实现组件级代码分割
- **类型系统**：强制使用 PropTypes，确保类型安全
- **性能监控**：内置性能监控和用户行为分析工具

## 3. 当前状态与挑战（Current Problems）

1.  **逻辑与视图耦合**：许多组件的状态管理逻辑散落在业务页面中，导致组件不够独立，复用困难。
2.  **样式定义分散**：同时存在`styleUtils.js`、`styled-components`和内联样式三种方式，缺乏统一规范。
3.  **缺乏动态与逻辑复用**：许多组件多为静态展示，缺少配套的、可复用的逻辑层（Hooks）。
4.  **性能优化空间**：核心组件未默认实现懒加载（Lazy Loading），在大型页面中可能存在性能瓶颈。
5.  **缺乏监控与分析**：没有充分利用内置的性能监控和用户行为分析能力。
6.  **测试覆盖不足**：组件缺乏自动化测试，存在质量隐患。
7.  **组件分层不完整**：虽然已初步实施原子设计，但仍有组件未按照正确层级组织。

## 4. 解决方案与实施进展

### 4.1 逻辑与视图分离的实施
  
- **进行中**：
  - 继续将组件重构为原子设计结构
  - 为更多组件创建专用Hook

### 4.2 性能优化实施

  
- **进行中**：
  - 对大型组件实施懒加载
  - 对列表组件应用虚拟滚动优化
  - 完善组件性能监控覆盖率

### 4.4 测试框架实施

  
- **进行中**：
  - 为重构后的组件添加单元测试
  - 建立端到端测试基础设施

## 5. 性能优化策略

为确保主题系统的高性能，我们采用以下策略：

1. **代码分割**：
   - 组件级别代码分割，非首屏组件使用`React.lazy`懒加载
   - 路由级别代码分割，使用`React.Suspense`和`React.lazy`实现

2. **资源优化**：
   - 图标使用SVG内联或图标字体，减少HTTP请求
   - 图片使用WebP格式，并实现响应式加载
   - 使用`preload`、`prefetch`策略预加载关键资源

3. **渲染优化**：
   - 使用`React.memo`避免不必要的重渲染
   - 使用`useCallback`和`useMemo`缓存函数和计算结果
   - 长列表使用虚拟滚动技术(react-window)

4. **样式优化**：
   - 使用CSS变量实现主题切换，避免重新计算样式
   - 关键CSS内联，非关键CSS异步加载
   - 避免CSS阻塞渲染

## 7. 监控与测试

### 7.1 性能监控

- **核心指标**：首次内容绘制(FCP)、最大内容绘制(LCP)、首次输入延迟(FID)、累积布局偏移(CLS)
- **监控方式**：使用Web Vitals库收集真实用户数据
- **预警机制**：当性能指标下降超过20%时自动告警


## 8. AI开发核心规范

**AI在执行开发任务时，必须严格遵循以下规则：**

1.  **规则1：逻辑先行，Hook优先**
    - 在创建任何有状态或有副作用的组件（分子/有机体级别）时，**必须**优先创建对应的`useComponent` Hook来封装其所有逻辑。
    - 所有Hook必须遵循React Hooks规范，并包含完整的JSDoc注释。

2.  **规则2：常量优先，杜绝硬编码**
    - **严禁**在组件样式中硬编码任何颜色、间距、字号等值。**必须**全部使用`src/theme/tokens.js`或`src/theme/styles/uiConstants.js`中定义的令牌和常量。
    - 新增设计令牌时，必须同时更新文档和类型定义。

3.  **规则3：性能默认，懒载先行**
    - 对于所有"有机体"级别的组件（如`NavBar`, 复杂表单等），**必须**默认使用`React.lazy`和`Suspense`进行懒加载处理。
    - 必须为每个组件添加`displayName`，便于性能分析和调试。
    - 列表渲染必须考虑虚拟化，当列表项超过50个时强制使用虚拟列表。

4.  **规则4：文档同步，示例驱动**
    - 每创建一个新的组件，**必须**同步创建一个对应的示例文件，展示其不同状态下的表现。
    - 组件文档必须包含Props表格、使用示例和注意事项。

5.  **规则5：样式统一，工具先行**
    - 推荐使用`styleUtils.js`中的工具函数创建标准样式。对于复杂或一次性样式，应使用`styled-components`，**避免**使用内联`style`属性。
    - CSS-in-JS中避免使用嵌套选择器，保持样式结构扁平。

6.  **规则6：原子化提交**
    - 组件（.js）、其样式、对应的Hook（.js）、测试（.test.js）和文档应在一个原子提交（Commit）中完成，确保功能完整性。

7.  **规则7：可访问性内置**
    - 所有交互组件必须支持键盘操作，并包含适当的ARIA属性。
    - 颜色对比度必须符合WCAG AA级标准（正文4.5:1，大文本3:1）。

8.  **规则8：测试驱动开发**
    - 新组件开发必须先编写测试用例，然后实现功能，确保测试覆盖率>80%。
    - 每个组件至少包含基本渲染测试、交互测试和边界条件测试。
    
9.  **规则9：组件层次遵循**
    - 严格遵循原子设计分层：原子不依赖其他组件，分子依赖原子，有机体依赖分子和原子，模板依赖有机体、分子和原子。
    - 禁止引用循环依赖，严格维护单向数据流。
    
10. **规则10：性能监控集成**
    - 必须使用performance.js中的工具监控关键组件和函数性能。
    - 对性能敏感组件必须设置性能基准，并在开发中持续监控。

## 9. 项目状态总结

1. **组件库补全**：继续开发更多原子和分子级组件，确保覆盖所有常用UI场景
3. **组件文档完善**：完善组件使用文档和示例，增加Storybook支持
4. **性能优化落实**：实施已规划的性能优化策略，特别是对大型组件的懒加载

## 10. 实施成果

下面具体介绍我们主题系统重构过程中的一些关键成果:

### 10.1 逻辑与视图分离

重构前，Toast组件的逻辑和UI耦合在一起，重构后:

```jsx
// 1. 使用ToastProvider封装全局Toast状态
<ToastProvider>
  <App />
</ToastProvider>

// 2. 在组件中使用useToast钩子
const MyComponent = () => {
  const { showToast } = useToast();
  
  const handleSuccess = () => {
    showToast('操作成功', 'success');
  };
  
  return <Button onClick={handleSuccess}>提交</Button>;
};
```

### 10.2 性能监控工具应用

所有重构组件均已加入性能监控:

```jsx
const Button = (props) => {
  // 性能监控
  useComponentPerformance('Button');
  
  // 组件逻辑...
};

// 添加displayName便于性能分析
Button.displayName = 'Button';
```

### 10.3 原子组件示例

Text原子组件提供丰富的文本显示能力:

```jsx
import { Text } from '../theme';

// 基础使用
<Text>默认文本</Text>

// 设置大小和颜色
<Text size="lg" color="primary">大号主色文本</Text>

// 设置粗细和截断
<Text weight="bold" truncate>加粗并自动截断的文本...</Text>
```

### 10.4 分子组件示例

Card分子组件基于原子组件封装:

```jsx
import { Card, Button } from '../theme';

<Card 
  title="卡片标题"
  subtitle="卡片副标题"
  cover="https://images.unsplash.com/photo-123456"
  actions={[
    <Button key="view">查看</Button>,
    <Button key="edit">编辑</Button>
  ]}
>
  卡片内容区域...
</Card>
```

以上成果表明，通过原子设计和逻辑分离原则的应用，我们的主题系统正在变得更加模块化、高性能和易维护。