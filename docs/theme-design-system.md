# Daily Discover - 前端主题设计系统架构与AI开发规范 v4.0

## 1. 核心原则与目标

本设计系统旨在构建一个**高性能、高可扩展、视觉高度一致**的前端UI体系。它不仅是组件库，更是指导AI进行高效、规范开发的核心规则集。

- **核心目标**：**效率提升与性能优化**。通过规范化、原子化的方式，最大化AI自主开发的范围，减少人工干预，实现快速迭代。
- **设计哲学**：**遵循原子设计（Atomic Design）**。将UI拆分为原子、分子、有机体、模板和页面五个层次，确保组件的独立性、复用性和可组合性。
- **性能第一**：所有组件和功能的设计都必须将性能作为首要考量，实施懒加载、代码分割、虚拟列表等策略，确保首屏加载时间<1.5s。
- **体验一致**：通过设计令牌（Design Tokens）和严格的开发规范，确保产品在所有场景下提供统一、可预测的用户体验。
- **可测试性**：每个组件必须具备良好的可测试性，支持单元测试和端到端测试，确保质量。
- **可扩展性**：采用插件化架构，支持功能的动态加载和卸载，为未来扩展做好准备。
- **逻辑与视图分离**：严格区分逻辑层(Hooks)和视图层(JSX)，提高代码可维护性和复用性。

## 2. 架构设计

### 2.1 原子设计（Atomic Design）分层

我们遵循原子设计思想，对`src/theme`目录进行逻辑分层：

- **Atoms (原子)**：构成UI的最基础元素，不可再分。
  - **职责**：只负责样式，不包含业务逻辑。
  - **特点**：高度可复用，几乎不包含状态，主要关注样式。
  - **示例**：`Text.js`、`Button.js`、基础样式元素。
- **Molecules (分子)**：由多个原子组合而成的简单UI组件。
  - **职责**：完成一个独立的、简单的功能。
  - **特点**：实现特定的UI功能，可包含简单交互。
  - **示例**：`InfoCard.js`、`FormField`。
- **Organisms (有机体)**：由多个分子或原子构成的复杂、独立的UI区域。
  - **职责**：代表产品中一个明确的功能区域。
  - **特点**：实现完整的业务功能，可能包含复杂状态。
  - **示例**：`NavBar`、`TopBar`。
- **Templates (模板)**：定义页面的整体布局和骨架。
  - **职责**：关注页面结构，不关心具体内容，是可复用的页面框架。
  - **特点**：定义页面骨架，接收内容填充。
  - **示例**：`BasePage.js`。

### 2.2 目录结构（优化后）

```
daily-discover-ui/src/theme/
├── components/              # UI组件 (按原子设计分层)
│   ├── atoms/              # 原子级组件
│   ├── molecules/          # 分子级组件
│   ├── organisms/          # 有机体级组件
│   └── templates/          # 模板级组件
├── hooks/                   # 组件逻辑钩子 (如: useToast.js)
├── providers/               # 全局状态提供者 (如: ToastProvider.js)
├── styles/                  # 样式工具
│   ├── uiConstants.js       # UI设计常量
│   ├── styleUtils.js        # 样式工具函数
│   └── commonStyles.js      # 通用样式
├── utils/                   # 工具函数
│   ├── performance.js       # 性能优化工具
│   ├── testing.js           # 测试辅助工具
│   └── analytics.js         # 分析与监控工具
├── tokens.js                # 设计令牌
├── GlobalStyles.js          # 全局样式
├── ThemeProvider.js         # 主题上下文
└── index.js                 # 主题系统统一导出
```

### 2.3 技术架构

- **核心技术栈**：React + styled-components + React Context
- **状态管理**：React Context + useReducer 模式，避免状态碎片化
- **样式方案**：styled-components 结合 Design Tokens，实现主题切换
- **组件加载**：React.lazy() + Suspense 实现组件级代码分割
- **类型系统**：强制使用 PropTypes，确保类型安全
- **性能监控**：内置性能监控和用户行为分析工具

## 3. 当前状态与挑战（Current Problems）

1.  **逻辑与视图耦合**：许多组件的状态管理逻辑散落在业务页面中，导致组件不够独立，复用困难。
2.  **样式定义分散**：同时存在`styleUtils.js`、`styled-components`和内联样式三种方式，缺乏统一规范。
3.  **缺乏动态与逻辑复用**：许多组件多为静态展示，缺少配套的、可复用的逻辑层（Hooks）。
4.  **性能优化空间**：核心组件未默认实现懒加载（Lazy Loading），在大型页面中可能存在性能瓶颈。
5.  **缺乏监控与分析**：没有充分利用内置的性能监控和用户行为分析能力。
6.  **测试覆盖不足**：组件缺乏自动化测试，存在质量隐患。
7.  **组件分层不完整**：虽然已初步实施原子设计，但仍有组件未按照正确层级组织。

## 4. 解决方案与实施进展

### 4.1 逻辑与视图分离的实施

- **进行中**：
  - 将剩余组件重构为原子设计结构
  - 为更多组件创建专用Hook

### 4.2 性能优化实施
  
- **进行中**：
  - 对大型组件实施懒加载
  - 对列表组件应用虚拟滚动优化

### 4.3 分析与监控实施

  
- **进行中**：
  - 建立性能基准和监控仪表盘
  - 实施性能回归测试系统

### 4.4 测试框架实施

  
- **进行中**：
  - 为核心组件添加单元测试
  - 建立端到端测试基础设施

## 5. 性能优化策略

为确保主题系统的高性能，我们采用以下策略：

1. **代码分割**：
   - 组件级别代码分割，非首屏组件使用`React.lazy`懒加载
   - 路由级别代码分割，使用`React.Suspense`和`React.lazy`实现

2. **资源优化**：
   - 图标使用SVG内联或图标字体，减少HTTP请求
   - 图片使用WebP格式，并实现响应式加载
   - 使用`preload`、`prefetch`策略预加载关键资源

3. **渲染优化**：
   - 使用`React.memo`避免不必要的重渲染
   - 使用`useCallback`和`useMemo`缓存函数和计算结果
   - 长列表使用虚拟滚动技术(react-window)

4. **样式优化**：
   - 使用CSS变量实现主题切换，避免重新计算样式
   - 关键CSS内联，非关键CSS异步加载
   - 避免CSS阻塞渲染

5. **监控与分析**：
   - 集成Lighthouse自动化性能评分
   - 实现核心Web指标(CWV)监控
   - 建立性能预算和自动预警机制


## 7. 监控与测试

### 7.1 性能监控

- **核心指标**：首次内容绘制(FCP)、最大内容绘制(LCP)、首次输入延迟(FID)、累积布局偏移(CLS)
- **监控方式**：使用Web Vitals库收集真实用户数据
- **预警机制**：当性能指标下降超过20%时自动告警

### 7.2 测试策略

- **单元测试**：使用Jest+React Testing Library测试组件逻辑
- **集成测试**：测试组件间交互和数据流
- **视觉测试**：使用Storybook+工具进行视觉回归测试
- **端到端测试**：关键流程使用测试工具进行端到端测试
- **性能测试**：使用性能测试工具进行基准测试

## 8. AI开发核心规范

**AI在执行开发任务时，必须严格遵循以下规则：**

1.  **规则1：逻辑先行，Hook优先**
    - 在创建任何有状态或有副作用的组件（分子/有机体级别）时，**必须**优先创建对应的`useComponent` Hook来封装其所有逻辑。
    - 所有Hook必须遵循React Hooks规范，并包含完整的JSDoc注释。

2.  **规则2：常量优先，杜绝硬编码**
    - **严禁**在组件样式中硬编码任何颜色、间距、字号等值。**必须**全部使用`src/theme/tokens.js`或`src/theme/styles/uiConstants.js`中定义的令牌和常量。
    - 新增设计令牌时，必须同时更新文档和类型定义。

3.  **规则3：性能默认，懒载先行**
    - 对于所有"有机体"级别的组件（如`NavBar`, 复杂表单等），**必须**默认使用`React.lazy`和`Suspense`进行懒加载处理。
    - 必须为每个组件添加`displayName`，便于性能分析和调试。
    - 列表渲染必须考虑虚拟化，当列表项超过50个时强制使用虚拟列表。

4.  **规则4：文档同步，示例驱动**
    - 每创建一个新的组件，**必须**同步创建一个对应的示例文件，展示其不同状态下的表现。
    - 组件文档必须包含Props表格、使用示例和注意事项。

5.  **规则5：样式统一，工具先行**
    - 推荐使用`styleUtils.js`中的工具函数创建标准样式。对于复杂或一次性样式，应使用`styled-components`，**避免**使用内联`style`属性。
    - CSS-in-JS中避免使用嵌套选择器，保持样式结构扁平。

6.  **规则6：原子化提交**
    - 组件（.js）、其样式、对应的Hook（.js）、测试（.test.js）和文档应在一个原子提交（Commit）中完成，确保功能完整性。

7.  **规则7：可访问性内置**
    - 所有交互组件必须支持键盘操作，并包含适当的ARIA属性。
    - 颜色对比度必须符合WCAG AA级标准（正文4.5:1，大文本3:1）。

8.  **规则8：测试驱动开发**
    - 新组件开发必须先编写测试用例，然后实现功能，确保测试覆盖率>80%。
    - 每个组件至少包含基本渲染测试、交互测试和边界条件测试。
    
9.  **规则9：组件层次遵循**
    - 严格遵循原子设计分层：原子不依赖其他组件，分子依赖原子，有机体依赖分子和原子，模板依赖有机体、分子和原子。
    - 禁止引用循环依赖，严格维护单向数据流。
    
10. **规则10：性能监控集成**
    - 必须使用performance.js中的工具监控关键组件和函数性能。
    - 对性能敏感组件必须设置性能基准，并在开发中持续监控。

## 9. 项目状态总结


需要继续完善的工作:

1. **组件库补全**：继续开发更多原子和分子级组件
2. **组件测试覆盖**：为现有组件添加单元测试
3. **组件文档完善**：完善组件使用文档和示例
4. **性能优化落实**：实施已规划的性能优化策略
5. **无障碍支持**：提升组件的可访问性

# NavBar 导航栏组件

NavBar是Daily Discover应用的底部导航栏组件，提供主要页面间的快速导航功能。

## 功能特性

- 支持通过React Router实现导航切换
- 带有突出显示的当前页面指示器
- 中央按钮区域可定制，支持显示用户头像或特定图标
- 自适应底部安全区域（支持iOS底部安全区域）
- 自动检测登录状态变化并更新UI

## 组件属性

| 属性 | 类型 | 默认值 | 说明 |
|------|------|-------|------|
| className | string | - | 自定义CSS类名，用于扩展样式 |

## 使用示例

```jsx
import { NavBar } from '../../theme/components';

// 基本用法
function AppLayout({ children }) {
  return (
    <div className="app-container">
      <main>{children}</main>
      <NavBar />
    </div>
  );
}

// 自定义样式
function CustomLayout({ children }) {
  return (
    <div className="app-container">
      <main>{children}</main>
      <NavBar className="custom-nav-bar" />
    </div>
  );
}
```

## 样式定制

NavBar组件使用UI常量系统进行样式定义，可以通过修改`uiConstants.js`中的常量来全局调整样式：

```javascript
// 在uiConstants.js中可调整的导航栏样式常量
export const UI_SIZES = {
  // ...其他尺寸常量
  NAV_HEIGHT: '56px',
  NAV_ICON_SIZE: '20px',
  NAV_TEXT_SIZE: '12px',
  NAV_TEXT_SPACING: '2px',
};
```

如果需要更具体的样式调整，可以使用`className`属性结合自定义CSS：

```css
/* 自定义导航栏样式 */
.custom-nav-bar {
  background-color: #fafafa;
  box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.1);
}
```

## 内部结构

NavBar组件包含以下主要部分：

1. **导航容器 (NavContainer)** - 固定在底部的主容器
2. **导航包装器 (NavWrapper)** - 布局和对齐导航项
3. **导航项目 (NavItem)** - 单个导航链接，包含图标和文本
4. **活动指示器 (NavIndicator)** - 显示当前活动页面
5. **中央按钮 (CenterButton)** - 特殊的中央按钮区域

## 实现细节

- 使用`useLocation`钩子检测当前路由路径
- 使用`isActive`函数确定哪个导航项处于激活状态
- 监听`loginStateChanged`事件以响应登录状态变化
- 根据登录状态自动显示用户头像或默认图标
- 使用styled-components实现样式隔离和主题支持

## 最佳实践

- NavBar通常应该放在应用布局的底部
- 可以配合顶部栏(TopBar)一起使用，形成完整的应用框架
- 导航项数量应控制在3-5个之间，保持简洁
- 避免在NavBar中放置过多文字内容

## 相关组件

- [TopBar](../TopBar/README.md) - 顶部导航栏
- [BasePage](../BasePage/README.md) - 基础页面布局 